static const int kLFOSize = 2048;
static float kLFOTable[kLFOSize];
static bool kTableInitialized = false;

void initLFOTable()
{
    if (kTableInitialized) return;
    const float twoPi = 6.28318530718f;
    for (int i = 0; i < kLFOSize; ++i)
    {
        kLFOTable[i] = std::sin((float)i / (float)kLFOSize * twoPi);
    }
    kTableInitialized = true;
}

JennyraveRedlineAudioProcessor::JennyraveRedlineAudioProcessor()
{
    initLFOTable();
}

JennyraveRedlineAudioProcessor::~JennyraveRedlineAudioProcessor() {}

void JennyraveRedlineAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    oversampler.initProcessing (samplesPerBlock);
    updateFilters(sampleRate * 2.0);

    for (int i = 0; i < 2; ++i)
    {
        hpFilters[i].reset();
        tiltFilters[i].reset();
        dcBlockers[i].reset();
        hysteresisMem[i] = 0.0f;
    }

    sampleCounter = 0;
    currentRedlineDrive = 0.0f;
    lfoIndex = 0.0f; 
    randomSeed = 0x12345;
}

void JennyraveRedlineAudioProcessor::updateFilters(double sampleRate)
{
    auto hpCoeffs = IIRCoefficients::makeHighPass(sampleRate, 35.0f);
    auto tiltCoeffs = IIRCoefficients::makeHighShelf(sampleRate, 3000.0f, 0.707f, 1.25f); 
    auto dcCoeffs = IIRCoefficients::makeHighPass(sampleRate, 5.0f);

    for (int i = 0; i < 2; ++i)
    {
        hpFilters[i].setCoefficients(hpCoeffs);
        tiltFilters[i].setCoefficients(tiltCoeffs);
        dcBlockers[i].setCoefficients(dcCoeffs);
    }
}

void JennyraveRedlineAudioProcessor::processBlock (AudioBuffer<float>& buffer, MidiBuffer& midiMessages)
{
    if (*apvts.getRawParameterValue("bypass") > 0.5f) return;

    targetRedlineDrive = *apvts.getRawParameterValue("redline");

    auto block = ProcessingBlock(buffer);
    auto upsampledBlock = oversampler.processSamplesUp(block);

    for (int channel = 0; channel < upsampledBlock.getNumChannels(); ++channel)
    {
        float* channelData = upsampledBlock.getChannelPointer(channel);
        
        for (int i = 0; i < upsampledBlock.getNumSamples(); ++i)
        {
            if (sampleCounter++ >= updateInterval)
            {
                sampleCounter = 0;
                currentRedlineDrive += (targetRedlineDrive - currentRedlineDrive) * 0.1f;
            }

            float driftIntensity = (currentRedlineDrive / 99.9f) * 0.15f; 
            float currentDrift = kLFOTable[(int)lfoIndex] * driftIntensity;
            
            lfoIndex += 0.005f; 
            if (lfoIndex >= (float)kLFOSize) lfoIndex -= (float)kLFOSize;

            float sample = channelData[i] + getFastNoise();
            
            sample = hpFilters[channel].processSingleSampleRaw(sample);
            sample = tiltFilters[channel].processSingleSampleRaw(sample);
            sample = processFabricTear(sample, currentRedlineDrive, currentDrift, channel);
            sample = apply56kOutputStage(sample);
            channelData[i] = dcBlockers[channel].processSingleSampleRaw(sample);
        }
    }

    oversampler.processSamplesDown(block);

    float compensation = 1.0f / (1.0f + (currentRedlineDrive * 0.17f));
    buffer.applyGain(compensation);
}

float JennyraveRedlineAudioProcessor::processFabricTear(float sample, float drive, float drift, int channel)
{
    float input = sample * (1.0f + (drive * 0.2f)); 
    float history = hysteresisMem[channel];
    float damping = std::max(0.0f, 0.3f - (std::abs(input) * 0.05f)); 
    float signal = input + (history * damping) + drift;

    float curvature = std::max(0.15f, 1.0f - (drive * 0.0085f));
    float shapedSample = signal / (curvature + std::abs(signal));
    
    hysteresisMem[channel] = shapedSample;
    return shapedSample;
}

float JennyraveRedlineAudioProcessor::apply56kOutputStage(float sample)
{
    const float bitDepthScale = 8388608.0f; 
    float quantized = std::round(sample * bitDepthScale) / bitDepthScale;
    return std::clamp(quantized, -0.9885f, 0.9885f);
}

float JennyraveRedlineAudioProcessor::getFastNoise()
{
    randomSeed = randomSeed * 196314165 + 907633515;
    return (float)((int32_t)randomSeed) * (4.6566128736e-10f) * 0.00001f; 
}

const String JennyraveRedlineAudioProcessor::getName() const { return "jennyrave redline"; }

void JennyraveRedlineAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    auto xml = apvts.copyState().createXml();
    copyXmlToBinary (*xml, destData);
}

void JennyraveRedlineAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    auto xml = getXmlFromBinary (data, sizeInBytes);
    if (xml != nullptr) apvts.replaceState (ValueTree::fromXml (*xml));
}

AudioProcessor* createPluginFilter() { return new JennyraveRedlineAudioProcessor(); }
